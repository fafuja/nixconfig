{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.modules.librewolf;

  librewolfPath = ".librewolf";

  extensionPath = "extensions/{ec8030f7-c20a-464f-9b0e-13a3a9e97384}";

  jsonFormat = pkgs.formats.json { };

  profiles = flip mapAttrs' cfg.profiles (_: profile:
    nameValuePair "Profile${toString profile.id}" {
      Name = profile.name;
      Path = profile.path;
      IsRelative = 1;
      Default = if profile.isDefault then 1 else 0;
    }) // {
      General = { StartWithLastProfile = 1; };
    };
  
  profilesIni = generators.toINI { } profiles;
  
  userPrefValue = pref:
    builtins.toJSON (if isBool pref || isInt pref || isString pref then
      pref
    else
      builtins.toJSON pref);

  mkOverridesFile = prefs: ''
    // Generated by Home Manager.

    ${concatStrings (mapAttrsToList (name: value: ''
      defaultPref("${name}", ${builtins.toJSON value});
    '') prefs)}
  '';

  mkUserJs = prefs: extraPrefs: bookmarks:
    let
      prefs' = lib.optionalAttrs ([ ] != bookmarks) {
        "browser.bookmarks.file" = toString (firefoxBookmarksFile bookmarks);
        "browser.places.importBookmarksHTML" = true;
      } // prefs;
    in ''
      // Generated by Home Manager.

      ${concatStrings (mapAttrsToList (name: value: ''
        user_pref("${name}", ${userPrefValue value});
      '') prefs')}

      ${extraPrefs}
    '';

in {
  meta.maintainers = [ maintainers.onny ];

  options.modules.librewolf = {
    enable = mkEnableOption "Librewolf browser, a privacy enhanced Firefox fork";

    package = mkOption {
      type = types.package;
      default = pkgs.librewolf;
      defaultText = literalExpression "pkgs.librewolf";
      description = "The LibreWolf package to use.";
    };
    
    settings = mkOption {
      type = with types; attrsOf (either bool (either int str));
      default = { };
      example = literalExpression ''
        {
          "webgl.disabled" = false;
          "privacy.resistFingerprinting" = false;
        }
      '';
      description = ''
        Attribute set of LibreWolf settings and overrides. Refer to
        <https://librewolf.net/docs/settings/>
        for details on supported values.
      '';
    };

    profiles = mkOption {
      type = types.attrsOf (types.submodule ({config, name, ...}: {
        options = {
	  name = mkOption {
	    type = types.str;
	    default = name;
	    description = "Profile name.";
	  };

	  id = mkOption {
	    type = types.ints.unsigned;
	    default = 0;
	    description = ''
	      Profile ID. This should be set to a unique number per profile.
	    '';
	  };

	  settings = mkOption {
	    type = types.attrsOf (jsonFormat.type // {
	      description = "Librewolf preference";
	    });
	    default = { };
            description = "Attribute set of Librewolf preferences.";
	  };

	  extraConfig = mkOption {
            type = types.lines;
            default = "";
            description = "Extra preferences to add to {file}`user.js`.";
          };

	  userChrome = mkOption {
	    type = types.lines;
	    default = "";
	    description = "Custom Librewolf user chrome CSS.";
	  };

	  userContent = mkOption {
	    type = types.lines;
	    default = "";
	    description = "Custom Librewolf user content CSS.";
	  };

	  path = mkOption {
	    type = types.str;
	    default = name;
	    description = "Profile path.";
	  };

	  isDefault = mkOption {
	    type = types.bool;
	    default = config.id == 0;
	    defaultText = "true if profile ID is 0.";
	    description = "Whether this is a default profile.";
	  };

	  search = {
	    force = mkOption {
	      type = with types; bool;
	      default = false;
	      description = "Whether to force replace the existing search configuration.";
	    };
	    default = mkOption {
	      type = with types; nullOr str;
	      default = "DuckDuckGo";
	      description = "The default search engine used in the address bar and search bar.";
	    };
	    order = mkOption {
	      type = with types; uniq (listOf str);
	      default = [ ];
	      example = [ "DuckDuckGo" "Google" ];
	      description = "The order the search engines are listed in.";
	    };
	    engines = mkOption {
	      type = with types; attrsOf (attrsOf jsonFormat.type);
	      default = { };
	      description = "Attribute set of search engine configurations.";
	    };
	  };
	  
	  extensions = mkOption {
	    type = types.listOf types.package;
	    default = [ ];
	    description = "List of Firefox add-on packages to install for this profile.";
	  };
	};
      }));
      default = { };
      description = "Attribute set of Librewolf profiles.";
    };
  };

# Problem here
  config = mkIf cfg.enable {
    assertions = [
      (let
        defaults =
          catAttrs "name" (filter (a: a.isDefault) (attrValues cfg.profiles));
      in {
        assertion = cfg.profiles == { } || length defaults == 1;
        message = "Must have exactly one default Firefox profile but found "
          + toString (length defaults) + optionalString (length defaults > 1)
          (", namely " + concatStringsSep ", " defaults);
      })

      (let
        duplicates = filterAttrs (_: v: length v != 1) (zipAttrs
          (mapAttrsToList (n: v: { "${toString v.id}" = n; }) (cfg.profiles)));

        mkMsg = n: v: "  - ID ${n} is used by ${concatStringsSep ", " v}";
      in {
        assertion = duplicates == { };
        message = ''
          Must not have Firefox profiles with duplicate IDs but
        '' + concatStringsSep "\n" (mapAttrsToList mkMsg duplicates);
      })

      (lib.hm.assertions.assertPlatform "programs.librewolf" pkgs
        lib.platforms.linux)
    ];

    home.packages = [ cfg.package ];

    home.file = mkMerge ([{
      "${librewolfPath}/profiles.ini" =
        mkIf (cfg.profiles != { }) { text = profilesIni; };
    }] ++ flip mapAttrsToList cfg.profiles (_: profile: {
      "${librewolfPath}/librewolf.overrides.cfg".text =
        mkOverridesFile cfg.settings;
      "${librewolfPath}/${profile.path}/.keep".text = "";
      "${librewolfPath}/${profile.path}/chrome/userChrome.css" =
        mkIf (profile.userChrome != "") { text = profile.userChrome; };
      "${librewolfPath}/${profile.path}/chrome/userContent.css" =
        mkIf (profile.userContent != "") { text = profile.userContent; };
      "${librewolfPath}/${profile.path}/user.js" = mkIf (profile.settings != { }
        || profile.extraConfig != "") {
          text = mkUserJs profile.settings profile.extraConfig [];
        };
      "${librewolfPath}/${profile.path}/extensions" =
        mkIf (profile.extensions != [ ]) {
          source = let
            extensionsEnvPkg = pkgs.buildEnv {
              name = "firefox-addons";
              paths = profile.extensions;
            };
          in "${extensionsEnvPkg}/share/mozilla/${extensionPath}";
          recursive = true;
          force = true;
        };

      "${librewolfPath}/${profile.path}/search.json.mozlz4" = mkIf 
        (profile.search.default != null || profile.search.order != [ ] || profile.search.engines != { }) 
      {  
	force = profile.search.force;
	source = let
	  settings = {
	    version = 6;
	    engines = let
              internalFieldNames = (genAttrs [
                "name"
                "isAppProvided"
                "loadPath"
                "hasPreferredIcon"
                "updateInterval"
                "updateURL"
                "iconUpdateURL"
                "iconURL"
                "iconMapObj"
                "metaData"
                "orderHint"
                "definedAliases"
                "urls"
              ] (name: "_${name}")) // {
                searchForm = "__searchForm";
	      };
              processCustomEngineInput = input:
                (removeAttrs input [ "icon" ])
                // optionalAttrs (input ? icon) {
                  iconURL = "file://${input.icon}";
                } // (optionalAttrs (input ? iconUpdateURL) {
                  iconURL = input.iconURL or input.iconUpdateURL;
                } // {
                  loadPath = ''
                    [home-manager]/modules.librewolf.profiles.${profile.name}.search.engines."${
                      replaceStrings [ "\\" ] [ "\\\\" ] input.name
                    }"'';
                });
	      processEngineInput = name: input:
                let
                  requiredInput = {
                    inherit name;
                    isAppProvided = input.isAppProvided or removeAttrs input
                      [ "metaData" ] == { };
                    metaData = input.metaData or { };
                  };
                in if requiredInput.isAppProvided then
                  requiredInput
                else
                  processCustomEngineInput (input // requiredInput);
	      
	      buildEngineConfig = name: input:
                mapAttrs' (name: value: {
                  name = internalFieldNames.${name} or name;
                  inherit value;
                }) (processEngineInput name input);
	      
	      sortEngineConfigs = configs:
                let
                  buildEngineConfigWithOrder = order: name:
                    let
                      config = configs.${name} or {
                        _name = name;
                        _isAppProvided = true;
                        _metaData = { };
                      };
                    in config // {
                      _metaData = config._metaData // { inherit order; };
                    };

                  engineConfigsWithoutOrder =
                    attrValues (removeAttrs configs profile.search.order);

                  sortedEngineConfigs =
                    (imap buildEngineConfigWithOrder profile.search.order)
                    ++ engineConfigsWithoutOrder;
                in sortedEngineConfigs;

              engineInput = profile.search.engines // {
                # Infer profile.search.default as an app provided
                # engine if it's not in profile.search.engines
                ${profile.search.default} =
                  profile.search.engines.${profile.search.default} or { };
              };
	      #
            in sortEngineConfigs (mapAttrs buildEngineConfig engineInput);

	    metaData = optionalAttrs (profile.search.default != null) {
              current = profile.search.default;
              hash = "@hash@";
            } // {
              useSavedOrder = profile.search.order != [ ];
            };
	  }; #settings
	  
	  salt = if profile.search.default != null then
            profile.path + profile.search.default
          else
	    null;
	in pkgs.runCommand "search.json.mozlz4" {
          nativeBuildInputs = with pkgs; [ mozlz4a openssl ];
          json = builtins.toJSON settings;
          inherit salt;
        } ''
            if [[ -n $salt ]]; then
              export hash=$(echo -n "$salt" | openssl dgst -sha256 -binary | base64)
              mozlz4a <(substituteStream json search.json.in --subst-var hash) "$out"
            else
              mozlz4a <(echo "$json") "$out"
            fi
          '';
      }; #search path
    }));
  };
}
